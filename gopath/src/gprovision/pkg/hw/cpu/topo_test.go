// Copyright (C) 2015-2020 the Gprovision Authors. All Rights Reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// SPDX-License-Identifier: BSD-3-Clause
//

package cpu

import (
	"fmt"
	fp "path/filepath"
	"runtime"
	"testing"
)

type cpuData struct {
	in        []byte
	want      CpuSet
	expectErr bool
}

func TestGetCpuList(t *testing.T) {
	cs := getCpuList(fp.Join(sysCpu, "cpu0", cS))
	n := runtime.NumCPU() // less than or equal to true number of cpus; affected by cpu bans, etc
	//proper values vary by machine, this test can't be very specific
	if len(cs) < n {
		t.Errorf("bad data %v", cs)
	}
	if len(cs) != n {
		t.Logf("potential problem: runtime reports %d cpus, while we have %d in %v", n, len(cs), cs)
	}
}

func TestPopulateMaps(t *testing.T) {
	populateMaps()

	if len(coreSib) == 0 {
		t.Errorf("zero-len coreSib")
	}
	if len(threadSib) == 0 {
		t.Errorf("zero-len threadSib")
	}
}

//func parseCpuList(lst []byte) (s CpuSet)
func TestParseCpuList(t *testing.T) {
	testData := []cpuData{
		{[]byte("0-7,45-49,52\n"), CpuSet([]uint16{0, 1, 2, 3, 4, 5, 6, 7, 45, 46, 47, 48, 49, 52}), false},
		{[]byte("a-4"), CpuSet([]uint16{}), true},
		{[]byte("1"), CpuSet([]uint16{1}), false},
		{[]byte("1,1"), CpuSet([]uint16{1}), true},
		{[]byte("1-1"), CpuSet([]uint16{}), true},
		{[]byte("1-2"), CpuSet([]uint16{1, 2}), false},
		{[]byte("1.2"), CpuSet([]uint16{}), true},
	}
	for i, d := range testData {
		s, err := parseCpuList(d.in)
		if (err != nil) != d.expectErr {
			t.Errorf("run %d: expectErr==%t, err==%s", i, d.expectErr, err)
		}

		if len(s) != len(d.want) {
			t.Errorf("run %d:\nwant %v\ngot  %v\n", i, d.want, s)
		}
		for _, v := range s {
			found := false
			for _, w := range d.want {
				if w == v {
					if found {
						t.Errorf("run %d: multiple entries for %d", i, v)
					}
					found = true
				}
			}
			if !found {
				t.Errorf("run %d: got %d, which is not in expected set", i, v)
			}
		}
	}
}

/* small
cpus:  [0 1 2 3]
threadSib: cpu.topo{0x0:cpu.CpuSet{0x0, 0x2}, 0x1:cpu.CpuSet{0x1, 0x3}, 0x2:cpu.CpuSet{0x0, 0x2}, 0x3:cpu.CpuSet{0x1, 0x3}}
coreSib: cpu.topo{0x0:cpu.CpuSet{0x0, 0x1, 0x2, 0x3}, 0x1:cpu.CpuSet{0x0, 0x1, 0x2, 0x3}, 0x2:cpu.CpuSet{0x0, 0x1, 0x2, 0x3}, 0x3:cpu.CpuSet{0x0, 0x1, 0x2, 0x3}}

original
cpus:  [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
threadSib: cpu.topo{0x4:cpu.CpuSet{0x4, 0x10}, 0x8:cpu.CpuSet{0x8, 0x14}, 0xa:cpu.CpuSet{0xa, 0x16}, 0x13:cpu.CpuSet{0x7, 0x13}, 0x14:cpu.CpuSet{0x8, 0x14}, 0x15:cpu.CpuSet{0x9, 0x15}, 0x5:cpu.CpuSet{0x5, 0x11}, 0xf:cpu.CpuSet{0x3, 0xf}, 0x10:cpu.CpuSet{0x4, 0x10}, 0x16:cpu.CpuSet{0xa, 0x16}, 0x17:cpu.CpuSet{0xb, 0x17}, 0x0:cpu.CpuSet{0x0, 0xc}, 0x3:cpu.CpuSet{0x3, 0xf}, 0x7:cpu.CpuSet{0x7, 0x13}, 0x9:cpu.CpuSet{0x9, 0x15}, 0xd:cpu.CpuSet{0x1, 0xd}, 0x12:cpu.CpuSet{0x6, 0x12}, 0x11:cpu.CpuSet{0x5, 0x11}, 0x1:cpu.CpuSet{0x1, 0xd}, 0x2:cpu.CpuSet{0x2, 0xe}, 0x6:cpu.CpuSet{0x6, 0x12}, 0xb:cpu.CpuSet{0xb, 0x17}, 0xc:cpu.CpuSet{0x0, 0xc}, 0xe:cpu.CpuSet{0x2, 0xe}}
coreSib: cpu.topo{
0x16:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x17:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x0:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x2:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x9:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0xf:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x11:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x4:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x6:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x7:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x14:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0xc:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0xd:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0xe:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x1:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x3:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x5:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x8:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0xa:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x12:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0xb:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x10:cpu.CpuSet{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11},
0x13:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},
0x15:cpu.CpuSet{0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}}

  lscpu
  NUMA node0 CPU(s):     0-5,12-17
  NUMA node1 CPU(s):     6-11,18-23

*/

//not really a test, but needs to be after TestParseCpuList
func Test__setupOriginalData(t *testing.T) {
	var firstSocket = CpuSet([]uint16{0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17})
	var secondSocket = CpuSet([]uint16{6, 7, 8, 9, 10, 11, 18, 19, 20, 21, 22, 23})
	allCpus = append(firstSocket, secondSocket...)
	numCpus = uint16(len(allCpus))
	populate := func(i, j uint16, sibs CpuSet, t topo) {
		for k := i; k <= j; k++ {
			t[k] = sibs
		}
	}
	coreSib = make(topo)
	populate(0, 5, firstSocket, coreSib)
	populate(6, 11, secondSocket, coreSib)
	populate(12, 17, firstSocket, coreSib)
	populate(18, 23, secondSocket, coreSib)
	threadSib = make(topo)
	var j uint16
	for j = 0; j < 12; j++ {
		s := CpuSet([]uint16{j, j + 12})
		threadSib[j] = s
		threadSib[j+12] = s
	}
	t.Logf("cpus: %#v", allCpus)
}

//func CreateSetWeighted(setSize int) (set CpuSet)
func TestCreateSetWeighted(t *testing.T) {
	checkSet := func(cpus CpuSet) {
		t.Logf("cpus %v\n", cpus)
		for i, c := range cpus {
			for j, d := range cpus {
				if j == i {
					continue
				}
				if c == d {
					t.Errorf("!!cpu %d at %d and %d", c, i, j)
				}
			}
			if cpus.ContainsTSib(c) && uint16(len(cpus)) <= numCpus/2 {
				t.Errorf("!!cpu list contains thread siblings of %d", c)
			}
		}
	}
	data := []int{2, 2, 20, 18, 33, 19, 34, 4}
	for _, d := range data {
		checkSet(CreateSetWeighted(d))
	}
	s := "cpu  "
	for _, c := range allCpus {
		s += fmt.Sprintf(" % 4d", c)
	}
	s += fmt.Sprintf("\nweight")
	minw, maxw := weight(0), 0.0
	for _, c := range allCpus {
		w := weight(c)
		if minw > w {
			minw = w
		}
		if maxw < w {
			maxw = w
		}
		s += fmt.Sprintf(" %3.2f", w)
	}
	t.Logf("min weight: %f    max weight: %f", minw, maxw)
	s += fmt.Sprintf("\nuse  ")
	minu, maxu := useCount[0], 0
	for _, c := range allCpus {
		u := useCount[c]
		if minu > u {
			minu = u
		}
		if maxu < u {
			maxu = u
		}
		s += fmt.Sprintf(" %4d", u)
	}
	use := "min use: %d   max use: %d"
	if maxu-minu > 1 {
		t.Errorf("improperly balanced - "+use, minu, maxu)
	} else {
		t.Logf(use, minu, maxu)
	}
	t.Logf("\n%s", s)
}
