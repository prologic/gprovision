// Copyright (C) 2015-2020 the Gprovision Authors. All Rights Reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// SPDX-License-Identifier: BSD-3-Clause
//

package backtrace

import (
	"gprovision/pkg/log"
	"os/exec"
	fp "path/filepath"
	"strings"
)

func FindExe(fname string) (exe string) {
	exe = findExeByName(fname)
	if exe != "" {
		return
	}
	exe = findExeWithGdb(fname)
	return
}

//guess executable from core name. assumes core name is standard format.
func findExeByName(corePath string) (exe string) {
	name := parseCoreName(corePath)
	if len(name) > 0 {
		var err error
		exe, err = exec.LookPath(name)
		if err != nil {
			ee, ok := err.(*exec.Error)
			if ok && ee.Err == exec.ErrNotFound {
				//did not find executable in PATH - don't log
				return
			}
			log.Logln("error searching for binary:", err)
		}
	}
	return
}

//parse core name
//assume core name is standard format
//[imagename_]exe-pid-uid-gid-sig-time.core
//note that exe will be thread name, if set - thus the imagename prefix
//imagename _and_ exe can contain dashes
func parseCoreName(corePath string) (exe string) {
	const minDashes = 5
	coreName := fp.Base(corePath)
	dashes := strings.Count(coreName, "-")
	if dashes < minDashes {
		log.Logln("expect more dashes:", corePath)
		return
	}
	lastDash := 0
	for dashes >= minDashes {
		lastDash += strings.IndexRune(coreName[lastDash:], '-') + 1
		dashes--
	}
	nameEnd := lastDash - 1
	if strings.Contains(coreName[:nameEnd], "_") {
		splat := strings.Split(coreName[:nameEnd], "_")
		if len(splat) == 2 {
			exe = splat[0]
		} else {
			log.Logln("failed to parse:", corePath)
		}
	} else {
		exe = coreName[:nameEnd]
	}
	return
}

//if all else fails, run gdb and see what it says
func findExeWithGdb(fname string) (exe string) {
	//gdb -ex q /bin/true chrome.core
	/*
	   ...
	   [New LWP 1804]
	   Core was generated by `/opt/google/chrome/chrome --type=renderer --field-trial-handle=3874718189913836'.
	   Program terminated with signal SIGILL, Illegal instruction.
	*/
	genBy := "Core was generated by `"
	cmd := exec.Command("gdb", "-ex", "q", "/bin/true", fname)
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Logln("while determining core's executable:", err)
		//don't return - try reading output anyway
	}
	lines := strings.Split(string(out), "\n")
	for _, l := range lines {
		if strings.HasPrefix(l, genBy) {
			cmdline := strings.TrimSuffix(strings.TrimPrefix(l, genBy), "'.")
			split := strings.Split(cmdline, " ")
			if len(split) > 0 {
				exe = split[0]
				break
			}
		}
	}
	if exe == "" {
		log.Logf("failed to parse gdb output\n%s\n", string(out))
	}
	log.Logf("gdb reports exe='%s'\n", exe)
	return
}
