// Copyright (C) 2015-2020 the Gprovision Authors. All Rights Reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// SPDX-License-Identifier: BSD-3-Clause
//

package raid

import (
	//"os"
	//"syscall"
	"testing"
)

/* works on some comps, fails on others...??
func TestLba2byte(t *testing.T) {
	var d Device
	var err error
	//for testing, open READ ONLY - so can't use d.Fd()
	d.fd, err = os.OpenFile("/dev/sda", syscall.O_DIRECT|os.O_RDONLY, 0400)
	if err != nil {
		t.Fatal(err)
	}
	var sector uint64 = 512

	d.lba2byte(0)
	if d.sectorSize != sector {
		t.Errorf("ioctl returned unexpected value. want %d, got %d", sector, d.sectorSize)
	}
}*/

func TestHasSig(t *testing.T) {
	buf := make([]byte, 512)

	if hasSig(buf, ddfHeaderSig) {
		t.Error("found ddfHeaderSig in 0-filled buffer")
	}

	//copy signature into buffer, but not at first byte
	for i, j := range ddfHeaderSig {
		buf[i+1] = j
	}

	if hasSig(buf, ddfHeaderSig) {
		t.Error("found ddfHeaderSig in buffer not starting with it")
	}
	if !hasSig(buf[1:], ddfHeaderSig) {
		t.Error("did not find ddfHeaderSig in buffer starting with it")
	}

}

/* real data from Intel S2400 with LSI ESRT2 */
var lsiAnchorHeader = [512]byte{
	0xde, 0x11, 0xde, 0x11, 0x9c, 0x93, 0xd8, 0x08,
	0x4c, 0x53, 0x49, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x80, 0x86, 0x29, 0x25, 0x00, 0x00, 0x00, 0x00,
	0x43, 0xac, 0x64, 0xb9, 0x43, 0xac, 0x78, 0xdd,
	0x30, 0x31, 0x2e, 0x30, 0x30, 0x2e, 0x30, 0x30,
	0x00, 0x00, 0x00, 0x03, 0x43, 0xac, 0x65, 0x2c,
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x74, 0x6f, 0xcd, 0xc0,
	0x00, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x2d, 0xd0,
	0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xac,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x23,
	0x00, 0x0f, 0x00, 0x0f, 0x00, 0x08, 0x00, 0x02,
	0x00, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x12,
	0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x08,
	0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x20, 0x00,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

func TestFindOffsets(t *testing.T) {
	buf := make([]byte, 512)
	a, b := findOffsets(buf)
	if a > 0 || b > 0 {
		t.Error("found offset in null data")
	}
	a, b = findOffsets(lsiAnchorHeader[:])
	if a != 1953484224 || b != 1953443280 {
		t.Errorf("bad offsets: want 1953484224, 1953443280. got %d, %d", a, b)
	}
}
